---
export interface Props {
  cards: Array<{
    image: string;
    alt: string;
    step: number;
    title?: string;
    description?: string;
  }>;
  tabId: string;
}

const { cards, tabId } = Astro.props;
---

<div class="card-slider" data-tab-id={tabId}>
  <div
    class="cards-container relative w-full h-[450px] lg:h-auto py-4 lg:py-14 xl:py-16 flex justify-center items-center"
  >
    {
      cards.map((card, index) => (
        <div
          class="card w-full max-w-[260px] rounded-4xl overflow-hidden shadow-card-claro absolute lg:relative cursor-grab active:cursor-grabbing"
          data-index={index}
        >
          <img
            class="w-full h-full object-cover"
            src={card.image}
            alt={card.alt}
          />
        </div>
      ))
    }

    <button
      class="nav-btn nav-prev absolute left-0 md:left-1/6 top-1/2 -translate-y-1/2 -translate-x-3 z-50 w-10 h-10 rounded-full text-[#FFC5C1] flex items-center justify-center shadow-lg lg:hidden transition-opacity duration-300 disabled:opacity-30 disabled:cursor-not-allowed"
      disabled
    >
      <svg
        class="w-full h-full"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M15 19l-7-7 7-7"></path>
      </svg>
    </button>
    <button
      class="nav-btn nav-next absolute right-0 md:right-1/6 top-1/2 -translate-y-1/2 translate-x-3 z-50 w-10 h-10 rounded-full text-[#FFC5C1] flex items-center justify-center shadow-lg lg:hidden transition-opacity duration-300 disabled:opacity-30 disabled:cursor-not-allowed"
    >
      <svg
        class="w-full h-full"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M9 5l7 7-7 7"></path>
      </svg>
    </button>
  </div>

  <div
    class="flex flex-col md:flex-row justify-center items-start gap-4 lg:gap-6 px-4 py-4 slider_participa_steps"
  >
    {
      cards.map((card) => (
        <div
          class="flex flex-col gap-1 hidden xl:flex w-full md:max-w-[210px] xl:max-w-[340px] duration-300"
          data-step={card.step}
        >
          <p class="text-center font-amx-black text-3xl">Paso {card.step}</p>
          {card.title && (
            <p
              class="text-center md:text-xs xl:text-lg leading-tight font-amx-regular text-balance xl:text-wrap"
              set:html={card.title}
            />
          )}
          {card.description && (
            <p class="text-center md:text-xs xl:text-lg leading-tight font-amx-regular text-balance">
              {card.description}
            </p>
          )}
        </div>
      ))
    }
  </div>
</div>

<script>
  import { gsap } from "gsap";
  import { Draggable } from "gsap/Draggable";

  gsap.registerPlugin(Draggable);

  const initSlider = (root: HTMLElement) => {
    const cards = gsap.utils.toArray(
      root.querySelectorAll<HTMLElement>(".card")
    ) as HTMLElement[];
    const sliderParticipaSteps = root.querySelector(
      ".slider_participa_steps"
    ) as HTMLElement | null;
    const navPrev = root.querySelector(".nav-prev") as HTMLButtonElement | null;
    const navNext = root.querySelector(".nav-next") as HTMLButtonElement | null;

    if (!cards.length || !sliderParticipaSteps) return;

    let currentIndex = 0;
    let draggableInstance: Draggable[] = [];
    let hoverListeners: Array<{
      element: HTMLElement;
      enter: () => void;
      leave: () => void;
    }> = [];
    let buttonListeners: Array<{ element: HTMLElement; handler: () => void }> =
      [];
    let currentMode: "mobile" | "desktop" | null = null;

    const updateStep = (index: number, isMobile: boolean) => {
      if (!sliderParticipaSteps) return;

      if (!isMobile) {
        sliderParticipaSteps.querySelectorAll("[data-step]").forEach((step) => {
          step.classList.remove("hidden");
        });
        return;
      }

      sliderParticipaSteps.querySelectorAll("[data-step]").forEach((step) => {
        step.classList.add("hidden");
      });
      const activeStep = sliderParticipaSteps.querySelector(
        `[data-step="${index + 1}"]`
      );
      activeStep?.classList.remove("hidden");

      if (navPrev) {
        navPrev.disabled = index === 0;
      }
      if (navNext) {
        navNext.disabled = index === cards.length - 1;
      }
    };

    const cleanup = () => {
      if (draggableInstance.length > 0) {
        draggableInstance.forEach((d) => d.kill());
        draggableInstance = [];
      }

      hoverListeners.forEach(({ element, enter, leave }) => {
        element.removeEventListener("mouseenter", enter);
        element.removeEventListener("mouseleave", leave);
      });
      hoverListeners = [];

      buttonListeners.forEach(({ element, handler }) => {
        element.removeEventListener("click", handler);
      });
      buttonListeners = [];

      cards.forEach((card) => {
        gsap.killTweensOf(card);
        gsap.set(card, { clearProps: "all" });
      });
    };

    const initMobile = () => {
      const cardPositions = [
        { x: 0, y: 0, rotation: 0, scale: 1, zIndex: 3, opacity: 1 },
        { x: 8, y: 12, rotation: 8, scale: 0.94, zIndex: 2, opacity: 0.9 },
        { x: -8, y: -12, rotation: -9, scale: 0.95, zIndex: 1, opacity: 0.9 },
      ];

      cards.forEach((card, i) => {
        const posIndex = (i - currentIndex + cards.length) % cards.length;
        const pos = cardPositions[Math.min(posIndex, 2)];

        gsap.set(card, {
          x: pos.x,
          y: pos.y,
          rotation: pos.rotation,
          scale: pos.scale,
          zIndex: pos.zIndex,
          opacity: posIndex < 3 ? pos.opacity : 0,
        });
      });

      let localDraggableInstance: Draggable[] | undefined;

      const animateToIndex = (newIndex: number) => {
        if (newIndex < 0 || newIndex >= cards.length) return;

        currentIndex = newIndex;

        cards.forEach((card, i) => {
          const posIndex = (i - currentIndex + cards.length) % cards.length;
          const pos = cardPositions[Math.min(posIndex, 2)];

          gsap.to(card, {
            x: pos.x,
            y: pos.y,
            rotation: pos.rotation,
            scale: pos.scale,
            zIndex: pos.zIndex,
            opacity: posIndex < 3 ? pos.opacity : 0,
            duration: 0.4,
            ease: "power2.inOut",
          });
        });

        updateStep(currentIndex, true);
      };

      const updateDraggable = () => {
        if (localDraggableInstance) {
          localDraggableInstance.forEach((d) => d.kill());
        }

        localDraggableInstance = Draggable.create(cards[currentIndex], {
          type: "x",
          bounds: { minX: -150, maxX: 150 },
          inertia: true,
          onDrag: function () {
            const dragPercent = Math.abs(this.x) / 150;
            gsap.to(cards[currentIndex], {
              rotation: this.x * 0.05,
              scale: 1 - dragPercent * 0.05,
              duration: 0.1,
            });
          },
          onDragEnd: function () {
            const dragDistance = this.x;

            if (dragDistance < -50 && currentIndex < cards.length - 1) {
              animateToIndex(currentIndex + 1);
              setTimeout(updateDraggable, 400);
            } else if (dragDistance > 50 && currentIndex > 0) {
              animateToIndex(currentIndex - 1);
              setTimeout(updateDraggable, 400);
            } else {
              gsap.to(cards[currentIndex], {
                x: 0,
                rotation: 0,
                scale: 1,
                duration: 0.4,
                ease: "back.out(1.2)",
              });
            }
          },
        });

        draggableInstance = localDraggableInstance;
      };

      updateDraggable();

      const prevHandler = () => {
        if (currentIndex > 0) {
          animateToIndex(currentIndex - 1);
          setTimeout(updateDraggable, 400);
        }
      };

      const nextHandler = () => {
        if (currentIndex < cards.length - 1) {
          animateToIndex(currentIndex + 1);
          setTimeout(updateDraggable, 400);
        }
      };

      if (navPrev) {
        navPrev.addEventListener("click", prevHandler);
        buttonListeners.push({ element: navPrev, handler: prevHandler });
      }
      if (navNext) {
        navNext.addEventListener("click", nextHandler);
        buttonListeners.push({ element: navNext, handler: nextHandler });
      }

      updateStep(currentIndex, true);
    };

    const initDesktop = () => {
      const rotations = [-10, 5, 10];
      const xOffsets = [20, 0, -20];
      const yOffsets = [-20, 30, 10];

      // Posición base de las cards
      cards.forEach((card, i) => {
        const originalZIndex = i === 1 ? 10 : 1;
        const ZIndexArr = [4, 2, 1];

        gsap.set(card, {
          rotation: rotations[i],
          x: xOffsets[i],
          zIndex: ZIndexArr[i],
        });

        const enterHandler = () => {
          const getStep = Number(card.getAttribute("data-index")) + 1;
          //sliderParticipaSteps.querySelector(`[data-step="${getStep}"]`).classList.remove("xl:opacity-50");
          gsap.to(card, {
            rotation: 0,
            scale: 1.08,
            duration: 0.3,
            zIndex: 20,
            y: 0,
            ease: "power2.out",
          });
        };

        const leaveHandler = () => {
          const getStep = Number(card.getAttribute("data-index")) + 1;
          //sliderParticipaSteps.querySelector(`[data-step="${getStep}"]`).classList.add("xl:opacity-50");
          gsap.to(card, {
            rotation: rotations[i],
            scale: 1,
            duration: 0.3,
            zIndex: ZIndexArr[i],
            y: yOffsets[i],
            ease: "power2.out",
          });
        };

        card.addEventListener("mouseenter", enterHandler);
        card.addEventListener("mouseleave", leaveHandler);

        hoverListeners.push({
          element: card,
          enter: enterHandler,
          leave: leaveHandler,
        });
      });

      // Animación de entrada tipo baraja (más desordenada)
      const deckIntro = () => {
        if (currentMode !== "desktop") return;

        cards.forEach((card, i) => {
          // Offsets aleatorios suaves para que el efecto se sienta más caótico
          const randomX = (Math.random() - 0.5) * 320; // -40 a 40
          const randomY = (Math.random() - 0.5) * 100; // -20 a 20
          const randomRot = (Math.random() - 0.5) * 20; // -7 a 7

          const fromX = xOffsets[i] - 200 + randomX;
          const fromY = -50 + randomY;
          const fromRotation = rotations[i] - 20 + randomRot;

          gsap.fromTo(
            card,
            {
              x: fromX,
              y: fromY,
              rotation: fromRotation,
              opacity: 0,
              scale: 0.85,
            },
            {
              x: xOffsets[i],
              y: yOffsets[i],
              rotation: rotations[i],
              opacity: 1,
              scale: 1,
              duration: 0.7,
              delay: i * 0.12,
              ease: "power3.out",
            }
          );
        });
      };

      // Llamar una vez al entrar en desktop
      deckIntro();

      // Permitir re-disparar la animación desde fuera (por ejemplo, al cambiar de tab)
      root.addEventListener("cards:enter", deckIntro);

      updateStep(0, false);
    };

    const init = () => {
      const isMobile = window.innerWidth < 1024;
      const nextMode: "mobile" | "desktop" = isMobile ? "mobile" : "desktop";

      if (currentMode === nextMode) return;

      cleanup();
      currentMode = nextMode;

      if (isMobile) {
        initMobile();
      } else {
        initDesktop();
      }
    };

    init();

    let resizeTimeout: number | undefined;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() => {
        init();
      }, 250);
    });
  };

  const sliders = document.querySelectorAll<HTMLElement>(".card-slider");
  sliders.forEach((root) => initSlider(root));

  const linkToC20pe2 = document.querySelector(
    ".linkToC20pe2"
  ) as HTMLAnchorElement;
  linkToC20pe2.addEventListener("click", (e) => {
    e.preventDefault();
    const c20peElement = document.querySelector(".c20pe") as HTMLElement;
    if (c20peElement) {
      const yOffset = -80;
      const y =
        c20peElement.getBoundingClientRect().top + window.pageYOffset + yOffset;
      window.scrollTo({
        top: y,
        behavior: "smooth",
      });
      setTimeout(() => {
        const actBtn = c20peElement.querySelector(
          ".actBtn"
        ) as HTMLElement | null;

        actBtn?.click();
      }, 600);
    }
  });
</script>
